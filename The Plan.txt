----------------------
How does the app work:
----------------------
    - A user starts the app:
        - The main menu opens
        - Log in automatically if user is remembered
            - Get users primary and secondary skins
            - Load in user's unlocked skins
            - Show option for user stats 
                - wins
                - losses
                - rank
                - sign out

    - The user selects local pvp
        - The LocalGame react-route is loaded

    - The user selects Online Casual
        - If user not logged in, don't allow
        - Players post their primary skin
            - request:
                - image_name
        - Wait till both players have successfully posted
        - Players get opponent's primary skin
            - response:
                - image_name
        - Go to OnlineCasualGame react-route
            - boardData is managed in backend
            - player_turn is managed in backend
            - Route for placing piece:
                - Checks if it was received from the correct player
                - Update BoardData
                - Send response to both players if successful
                    - Player renders new piece in correct position
                    - request:
                        - player_id
                        - piece_position
                    - response:
                        - placement_successful (bool)
                        - player_won (bool)
                        - Does this need to be a separate route that players get from?
                - If player_won
                    - update records of both players accordingly

    - The user selects 'Online Ranked' (TBD)
    
    - The user selects skins
        - If the user isn't logged in, don't allow
        - I hate the idea of using context api, so I'd rather not
        - Show the current primary and secondary skins
            - The primary and secondary skin should've been gotten on login
        - User selects which one they would like to update
        - User can select from options they have unlocked
            - Should also be gotten on login
                - Skins should ordered, so just it could just be the index of the last skin unlocked
        - User can hit 'Apply' button
            - request:
                - primary_skin_name
                - secondary_skin_name


    - The user selects login
        - side menu to login shows up
        - on successful login
            - do as stated in the app start section
            - change the login button to profile button
        - sign-up button
            - generate new user_data with default values
            - log the user in automatically
            - do normal login process
        
------    
TO DO:  
------
    - Log in system (done)
        - Add a log in button (done)
        - Set up MongoDB cluster (done)
            - Make a collection for user_data
                - Decide what a user_data document looks like
        - Set up back end (express, MongoDB, prisma) (done)
        - Google oAuth
            - Need route for getting the user_data of signed in user
                - If new user, generate new user_data with default values (done)
            - Option for signing in is in the side menu of the log in button
        - If new user, generate user_data with default properties
            - decide what goes in a user_data document
        - Load in user_data
        - Change log in button to profile button
            - Display user data
            - Sign out button

    - Online Casual (done)
        - Matchmaking (done)
            - User clicks "Find Match" in the side menu.
            - Backend initiates matchmaking, trying to pair two available sessions.
            - Once matched, backend establishes a game session for both players.

        - Gameplay (done)
            - Player clicks forfeit (done)
            - Player attempts to place a piece on the board. (done)
                - Backend validates the move: (done)
                    - If invalid, sends a failure signal to the current player. (done)
                    - If valid, updates the game state, sends a success signal to both players, and switches the active player. (done)
                    - Frontend listens for signals from the backend and updates the board accordingly. (done)
                    - This can be done using WebSockets or polling for updates. (done)
                - If a win condition is detected:
                    - Display the winner. (done)
                    - Backend updates user stats.
                    - Clear the board and show rematch and menu options. (done)
                    - Backend manages rematch requests or disconnection. (done)

        - Post-Game (done)
            - Implement a timer for rematch decisions to keep the flow moving. (done)
            - Handle cases where one player wants a rematch and the other does not. (done)

    - Fix the board (done)
        - Insert pieces top-down (from the board to the column) (done)
        - Move state up (done)
            - Keep track of existing pieces in the board (done)
            - Columns call hook on board, that places piece (done)

    - Online Ranked (done)
        - Matchmaking
            - Players joins matchmaking
                - A balanced binary search tree (e.g., AVL tree, Red-Black tree) or a skip list???
                - Add them to a priority queue (user_data, client web socket, rating_range = 50, join_time)
                - Priority is ELO
                    - How navigable is a priority queue? 
                    - Search back and forth from spot?
                        - If you start from one end, and that player did not find match.
                        that player and all previous players are an invalid match for the 
                        next player, so you don't need to search backwards
                    - Implemented via list? Should I make a class for this ranked matchmaking queue?
            - While priority queue has people
                - Try to match people within their acceptable ranges
                    - Both ranges have to match up??? Or ranges just have to overlap??
                - If no match found after 1 second, increase rating_range by 10
                - If match found, make game session like normal, add extra variable to track if ranked
        - Frontend
            - OnlineGame component, add prop to track if ranked
                - display players ranks in the side margins if ranked
        - After match
            - In game_session, if ranked
                - Adjust ELO and Rank accordingly
                    - add a rankedService.js for these calculations?
                - Update on frontend




------------
Bugs To Fix:
------------
    - The empty game pieces are deleted starting from the top (fixed)
    - The game pieces won't stack when placed (probably related to above) (fixed)
    - The game pieces don't line up with the empty game pieces (fixed)
    - On rematch, the player in the backend isn't the right player (fixed)
    - The backend doesn't accept the forfeit message (fixed)
    - The 'Player Disconnected Overlay' is nothing like I wanted it (fixed)
    - Reload page gives error because it doesn't remember the game_session (fixed)
        - If no game_session, redirect to home page
    - Player records are not being updated in database (fixed)
    - Fetch user_data when the user goes to the MainMenu (fixed)
    - Get rid of game session when players leave game (fixed)
    - There's no time limit on each players turn (fixed)


---------------------------------------------
Future Things To Do When You Have Extra Time:
---------------------------------------------
    - Add animations to OnlineGamePieces
    - Make the ghost piece hover above columns
    - Remember game_session as part of user_data to help with page reloading (avoided)
    - Make it so that closing the window or reloading sends a forfeit and rematchDenied to the other player (done)
    - Get rid of the saving google ids, I feel like that's probably a bad thing to store
    - Add sound effects
    - Add music
    - Add options to change music and sound effects
    - Add more skins
    - Add AI opponent
        - Simple zero sum game
        - Expectimax
            - Adjust expectations for difficulty
    - Add profile pictures
    - Add ranked icons
    - Add option to change username